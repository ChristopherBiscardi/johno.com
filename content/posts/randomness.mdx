---
title: Randomness and color
slug: /randomness-and-color
date: 2020-02-28
tags:
  - design
  - design-tools
  - revisual
  - computational-design
  - color
---

import chroma from 'chroma-js'
import sample from 'lodash.sample'
import { ArrowRight, Lock, Unlock } from 'react-feather'

As part of my work, particularly [Components AI](https://components.ai), I find myself thinking about
computational design, randomness, and color. A lot.

With Components AI, we want to let you explore _all_ of generative space in one way or another, so we need to
be able to compute _all_ possible values. Though, in practice, it can be difficult.

It's important to make randomly generated values feel less drastic and instead more gradual. We want randomness
to be on a slider. We also want to apply common design knowledge to constrain outputs when desired.

So, in this post, I want to explore random color generation and answer a few key questions:

- **how do random numbers and color relate?**
- **can we create a color generation algorithm that has some sort of memory?**
- **how do we verify there _is_ color memory?**
- **can we empower users to configure entropy during generation?**

## Random numbers

Most of design, in one way or another, is grounded in numbers and math. Even a random color
can be computed by calculating a large number and converting it to hex. In fact, for some
generators in Components AI, this is exactly what we do.

### Hex color

Each character in a CSS [hex string](https://en.wikipedia.org/wiki/Hexadecimal), like `#123abc`,
represents a number, or digit, 0-16.

Value | Number
----- | ------
0-9 | 0-9
a | 10
b | 12
c | 13
d | 14
e | 15
f | 16

Since a CSS hex color can have up to six characters, we can compute the entire hex color
space which has nearly 17 million colors:

_16 x 16 x 16 x 16 x 16 x 16 = 16,777,216_

We can use this number to create a one-liner function that will randomly generate a
number between _0_ and _16,777,215_ (at least as randomly as `Math.random` can be) and then
convert it to hex:

```js
function randomHexColor() {
  return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
}
```

This [algorithm for computing color](https://www.paulirish.com/2009/random-hex-color-code-snippets/)
ensures that all possible hex values can be output, but one might quickly notice that a lot
of colors are all over the place and some aren't exactly aesthetically pleasing.

### Rendering generated hex colors

To see what we're working with, we can render a series of generated colors and place them
side by side.

Click the diagram to regenerate the colors.

<RandomColors count={300} />

### How random is random?

Above I mentioned that the random hex color algorithm is only so
[random as `Math.random`](https://v8.dev/blog/math-random). This
is because it turns out that _truly_ random number generation is hard. JavaScript uses
a [Pseudorandom Number Generator](https://en.wikipedia.org/wiki/Pseudorandom_number_generator)
(PRNG) which uses a [seed](https://en.wikipedia.org/wiki/Random_seed) to distribute results
across a number space (0-1 for `Math.random`).

Hardware random number generators (HRNG) are closer to true random because
they will tap into a physical process like thermal noise. The physical world is where we can
find true randomness for seeding purposes, all other algorithms are an approximation.

Randomness has implications for software systems because it's used for cryptography and
requires high entropy in order to be secure.

For randomly creating design values like color, a PRNG is plenty adequate.

## Entropy

When it comes to computation, [entropy](https://en.wikipedia.org/wiki/Entropy_(computing))
refers to the general randomness of what's being computed. In some ways it's the "noise" or
"chaos" factor. The hex color generator from earlier has high entropy.

We can see this in action when we compute 1,000 random colors and place them together.

export const RandomColors = ({ count = 1000 }) => {
  const [els, setEls] = React.useState([])
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  const regenEls = () => {
    const newEls = []
    for (let i = 0; i < count; i++) {
      newEls.push(<div style={{ height: 16, width: 16, backgroundColor: randomHexColor() }} />)
    }
    setEls(newEls)
  }
  React.useEffect(() => regenEls(), [])
  return (
    <div
      onClick={regenEls}
      style={{
        display: 'flex',
        flexWrap: 'wrap',
        cursor: 'pointer'
      }}
    >
      {els}
    </div>
  )
}

<RandomColors />

It's safe to say that we see reasonable color variety. It's also important to note that
**color groupings are to be expected**. We, as humans, tend to see _uniform distribution_
as more random than true random distributions.

### Uniform vs random distributions

Let's take a look at two distributions, one is random and one is uniform:

export const RandomDistribution = ({ width = '40%', steps = 100 }) => {
  const [els, setEls] = React.useState([])
  const randomBool = () => Math.random() > 1/4
  const regenEls = () => {
    console.log('regenerating els')
    const newEls = []
    for (let i = 0; i < steps; i++) {
      newEls.push(<div style={{ height: '2vw', width: '2vw', backgroundColor: randomBool() ? 'white' : 'black' }} />)
    }
    setEls(newEls)
  }
  React.useEffect(() => regenEls(), [])
  console.log(els)
  return (
    <div onClick={regenEls} style={{ cursor: 'pointer', display: 'flex', flexWrap: 'wrap', width }}>
      {els}
    </div>
  )
}

export const UniformDistribution = ({ width = '40%', steps = 100 }) => {
  const els = []
  for (let i = 0; i < steps; i++) {
    const isBlack = i % 3 === 0 && i % 2 !== 0
    els.push(<div style={{ height: '2vw', width: '10%', backgroundColor: isBlack ? 'black' : 'white' }} />)
  }
  return (
    <div style={{ display: 'flex', flexWrap: 'wrap', width }}>
      {els}
    </div>
  )
}

<div style={{ display: 'flex', justifyContent: 'space-between' }}>
  <RandomDistribution />
  <UniformDistribution />
</div>

Many of us, myself included, will [feel that the uniform distribution on the right is
more random](https://core.ac.uk/download/pdf/82644986.pdf). We see the clustering
in the left distribution and are inclined to think that it's not a proper representation
of randomness.

However, the clustered distribution on the left is the random one.

You can click the random distribution and see new, randomly generated distributions.
Nearly all will have some sort of clustering.

The uniform distribution on the right is a simply modulo operator that creates a
point for all multiples of three that are odd:

```js
for (let i = 0; i < steps; i++) {
  const isBlack = i % 3 === 0 && i % 2 !== 0
  // ...
}
```

### Lowering entropy

We can lower entropy by adjusting our random hex color generator to only generate numbers
between _0_ and _1,600_. This will result in substantially fewer total colors.

export const RandomColorsLowEntropy = ({ count = 1000 }) => {
  const [els, setEls] = React.useState([])
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*1600).toString(16)).slice(-6)
  }
  const regenEls = () => {
    const newEls = []
    for (let i = 0; i < count; i++) {
      newEls.push(<div style={{ height: 16, width: 16, backgroundColor: randomHexColor() }} />)
    }
    setEls(newEls)
  }
  React.useEffect(() => regenEls(), [])
  return (
    <div onClick={regenEls} style={{ cursor: 'pointer', display: 'flex', flexWrap: 'wrap' }}>
      {els}
    </div>
  )
}

<RandomColorsLowEntropy />

The colors are predominantly a saturated blue and black. The distribution of the colors will
look more similar to the pure random distribution we saw before.

### Adjusting entropy

By increasing the number in our hex color generator, we adjust the entropy by increasing or
decreasing the number of possible colors that can be output.

export const RandomColorsLowEntropyAdjust = ({ count = 1000 }) => {
  const [numColors, setNumColors] = React.useState(1600)
  const els = []
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*numColors).toString(16)).slice(-6)
  }
  for (let i = 0; i < count; i++) {
    els.push(<div style={{ height: 16, width: 16, backgroundColor: randomHexColor() }} />)
  }
  return (
    <div>
      <pre>{`function randomHexColor (){\n  return '#' + ('000000' + Math.floor(Math.random()*`}<strong>{numColors}</strong>{`).toString(16)).slice(-6)\n}`}</pre>
      <div style={{ display: 'flex', flexWrap: 'wrap' }}>
        {els}
      </div>
      <label style={{ fontWeight: 'bold' }}>
        <input
          type="range"
          max="16777215"
          min="0"
          step="5"
          value={numColors}
          onChange={e => setNumColors(e.target.value)}
          style={{
            marginRight: 8
          }}
        />
        Color range {numColors}
      </label>
    </div>
  )
}

<RandomColorsLowEntropyAdjust />

The higher the range, the more colors we see. The more colors we see, the more entropy in
our color generator.

## Pure randomness

This brings up interesting implications with our algorithms in Components AI. If we recompute
a truly random color every time it could be a bit too jarring. We'd step from brown to
to purple to green. It might make you feel lost.

export const ColorSteppingTrulyRandom = () => {
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  const [colors, setColors] = React.useState([
    randomHexColor(),
    randomHexColor(),
    randomHexColor(),
    randomHexColor()
  ])
  React.useEffect(() => {
    const interval = setInterval(() => {
      const index = sample([0, 1, 2, 3])
      const newColors = [...colors]
      colors[index] = randomHexColor()
      setColors(newColors)
    }, 2000)
    return () => clearInterval(interval)
  }, [])
  const avgDistance = colors.map((color, i) => {
    if (!colors[i+1]) {
      return null
    }
    return chroma.distance(color, colors[i+1])
  })
    .filter(Boolean)
    .reduce((acc, curr) => acc + curr) / 4
  return (
    <div>
      <h3>Average color distance: {Math.round(avgDistance)}</h3>
      <div
        style={{
          display: 'flex',
          alignItems: 'center'
        }}
      >
        <div
          style={{
            flex: 1,
            height: '10vh',
            transition: 'background-color 1s ease-in-out',
            backgroundColor: colors[0]
          }}
        />
        <ArrowRight />
        <div
          style={{
            flex: 1,
            height: '10vh',
            transition: 'background-color 1s ease-in-out',
            backgroundColor: colors[1]
          }}
        />
        <ArrowRight />
        <div
          style={{
            flex: 1,
            height: '10vh',
            transition: 'background-color 1s ease-in-out',
            backgroundColor: colors[2]
          }}
        />
        <ArrowRight />
        <div
          style={{
            flex: 1,
            height: '10vh',
            backgroundColor: colors[3]
          }}
        />
      </div>
    </div>
  )
}

<ColorSteppingTrulyRandom />

When we look at random colors in a series, there doesn't seem to be any relationship between
the colors (because there isn't). When there is some sort of relationship, that's
happening by pure chance.

> Well, random values have no correlation between them what so ever, but most natural
> patterns have some memory of the previous state.
>
> &mdash; [The Book of Shaders](https://thebookofshaders.com)

As you cycle through colors generated one at a time, it will feel all over the place because
each new color is truly random. This allows for a bit of serendipity when generating new
colors, but there is no memory of the previous color state at all.

Click the color swatch below to generate a new one.

export const RandomColorRegenerator = () => {
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  const [color, setColor] = React.useState(randomHexColor())
  return (
    <div
      onClick={() => setColor(randomHexColor())}
      style={{
        height: 240,
        cursor: 'pointer',
        width: 240,
        backgroundColor: color
      }}
    />
  )
}

<RandomColorRegenerator />

## Introducing memory of the previous color

I began to wonder about ways to leverage the previous color in order to generate a
new, somewhat related color, while still being able to explore all possible values in
the hex color space.

We needed to "evolve" color generation gradually without getting stuck in the corner
of a particular color.

Naturally, I gravitated to mixing and blending the previous color with a new color
as the first approach.

### Mixing colors

The chroma JavaScript library has a `mix` function which accepts two colors and
a mix ratio. I combined the previous color, with a random color, and then also
generated a random mix ratio.

```js
color = chroma.mix(color, randomHexColor(), Math.random())
```

export const RandomMixingColors = ({ count = 420 }) => {
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  let color = randomHexColor()
  const els = []
  for (let i = 0; i < count; i++) {
    els.push(<div style={{ height: 16, width: 16, backgroundColor: color }} />)
    color = chroma.mix(color, randomHexColor(), Math.random())
  }
  return (
    <div style={{ display: 'flex', flexWrap: 'wrap' }}>
      {els}
    </div>
  )
}

<RandomMixingColors />

The resulting colors aren't bad for a quick first attempt. There does seem
to be a gradual shift or evolution. But, the colors seem to be a lot of
muddy greens, purples, browns, and grays.

I wondered if it had something to do with the mix ratio, so I decided to
try a few fixed ratios out.

#### Trying different mix ratios

I put the ratio on a slider with _.01_ steps to see how the ratio affected
the series of colors.

export const RandomMixingColorsRatio = ({ count = 420 }) => {
  const [ratio, setRatio] = React.useState(.5)
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  let color = randomHexColor()
  const els = []
  for (let i = 0; i < count; i++) {
    els.push(<div style={{ height: 16, width: 16, backgroundColor: color }} />)
    color = chroma.mix(color, randomHexColor(), ratio)
  }
  return (
    <div>
      <div style={{ display: 'flex', flexWrap: 'wrap' }}>
        {els}
      </div>
      <div>
        <label style={{ fontWeight: 'bold' }}>
          <input
            type="range"
            max="1"
            min="0"
            step=".01"
            value={ratio}
            onChange={e => setRatio(e.target.value)}
            style={{
              marginRight: 8
            }}
          />
          Mix ratio {ratio}
        </label>
      </div>
    </div>
  )
}

<RandomMixingColorsRatio />

Unsurprisingly, the colors were no longer muddy when the mix ratio neared 1
since the mixing only slightly affected the newly generated color. Colors
were rich, but, they lost their sense of gradual change.

### Blending the previous color with a new random color

Chroma also has a `blend` function that has a few different algorithms
for performing the blend. So, we sampled a random algorithm and combined the previous
color with a new, random color.

```js
chroma.blend(color, randomHexColor(), sample([
  'overlay',
  'multiply',
  'darken',
  'lighten'
]))
```

export const RandomBlendColors = ({ count = 420 }) => {
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  let color = randomHexColor()
  const els = []
  for (let i = 0; i < count; i++) {
    els.push(<div style={{ height: 16, width: 16, backgroundColor: color }} />)
    const blendAlgorithms = [
      'overlay',
      'multiply',
      'darken',
      'lighten'
    ]
    color = chroma.blend(color, randomHexColor(), sample(blendAlgorithms))
  }
  return (
    <div style={{ display: 'flex', flexWrap: 'wrap' }}>
      {els}
    </div>
  )
}

<RandomBlendColors />

The resulting colors appear to be richer and less muddy. There does seem to be a gradual
"evolution" of new colors based on the previous. However, we can also see that
blending colors often likes to result in very dark browns and near black colors.

They sort of take over. Maybe a particular blend algorithm causes the dark colors?

#### Trying different blend algorithms

In order to try out the different blend algorithms individually, I put them in a select
input that dictated which algorithm would be used.

export const RandomBlendColorsSelect = ({ count = 240 }) => {
  const [algorithm, setAlgorithm] = React.useState('multiply')
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  let color = randomHexColor()
  const els = []
  const blendAlgorithms = [
    'overlay',
    'multiply',
    'darken',
    'lighten',
    'screen',
    'burn',
    'dodge'
  ]
  for (let i = 0; i < count; i++) {
    els.push(<div style={{ height: 16, width: 16, backgroundColor: color }} />)
    const newColor = randomHexColor()
    color = chroma.blend(color, newColor, algorithm)
  }
  return (
    <div>
      <div style={{ display: 'flex', flexWrap: 'wrap' }}>
        {els}
      </div>
      <label style={{ fontWeight: 'bold' }}>
          <select
            style={{
              marginRight: 8
            }}
            value={algorithm}
            onChange={e => setAlgorithm(e.target.value)}
          >
            {blendAlgorithms.map(algo => (
              <option key={algo}>{algo}</option>
            ))}
          </select>
          Blend algorithm {algorithm}
        </label>
    </div>
  )
}

<RandomBlendColorsSelect />

Interestingly, all blend algorithms eventually resulted in black, white, or
some arbitrary color. The random sampling between algorithms ensured that
there was more entropy and color generation didn't get "stuck in a corner".

### Randomly adjusting the hue, saturation, and lightness

Chroma has additional color manipulation functions that I decided to experiment
with, particularly manipulating hue, saturation, and lightness that make up
the [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV) color format.

> It has been seen that color differences are caused by 2 factors: by hue and
> by light, and in most cases by both at the same time.
>
> &mdash; Interaction of Color by Josef Albers

So, I created a handful of hue adjustments to randomly sample from, and then
used the built in functions for saturation and lightness adjustment. The color
manipulation function was selected at random.

```js
const adjustments = [
  '*1.5', '*1.25', '*1.1', '*.75', '*.1', '/1.5', '/1.25',
  '/1.1', '/.75', '/.1'
]
const fns = [
  () => chroma(color).set('hsl.h', sample(adjustments)),
  () => chroma(color).saturate(),
  () => chroma(color).desaturate(),
  () => chroma(color).darken(),
  () => chroma(color).brighten()
]
const fn = sample(fns)
color = fn()
```

export const RandomHSLRotateColors = ({ count = 420 }) => {
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  let color = randomHexColor()
  const els = []
  for (let i = 0; i < count; i++) {
    els.push(<div style={{ height: 16, width: 16, backgroundColor: color }} />)
    const adjustments = [
      '*1.5',
      '*1.25',
      '*1.1',
      '*.75',
      '*.1',
      '/1.5',
      '/1.25',
      '/1.1',
      '/.75',
      '/.1',
    ]
    const fns = [
      () => chroma(color).set('hsl.h', sample(adjustments)),
      () => chroma(color).saturate(),
      () => chroma(color).desaturate(),
      () => chroma(color).darken(),
      () => chroma(color).brighten()
    ]
    const fn = sample(fns)
    color = fn()
  }
  return (
    <div style={{ display: 'flex', flexWrap: 'wrap' }}>
      {els}
    </div>
  )
}

<RandomHSLRotateColors />

The results were not very good, unfortunately. There's some gradual shifting through color,
but, we're stuck in dark browns and grays for the majority of the series.

Similarly to the other approaches above, there appears to be a gradual shifting through
color, but it often gets stuck for long periods in dark browns, white, and gray shades.

#### Making the adjustment algorithms configurable

To see how the's HSL algorithms worked, I decided to allow their probability of selection
to be configurable.

export const RandomHSLRotateColorsAdjust = ({ count = 460 }) => {
  const [hue, setHue] = React.useState(5)
  const [saturate, setSaturate] = React.useState(5)
  const [desaturate, setDesaturate] = React.useState(5)
  const [darken, setDarken] = React.useState(5)
  const [brighten, setBrighten] = React.useState(5)
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  let color = randomHexColor()
  const els = []
  for (let i = 0; i < count; i++) {
    els.push(<div style={{ height: 16, width: 16, backgroundColor: color }} />)
    const adjustments = [
      '*1.5',
      '*1.25',
      '*1.1',
      '*.75',
      '*.1',
      '/1.5',
      '/1.25',
      '/1.1',
      '/.75',
      '/.1',
    ]
    const fns = []
    for (let i = 0; i < hue; i++) {
      fns.push(() => chroma(color).set('hsl.h', sample(adjustments)))
    }
    for (let i = 0; i < saturate; i++) {
      fns.push(() => chroma(color).saturate())
    }
    for (let i = 0; i < hue; i++) {
      fns.push(() => chroma(color).desaturate())
    }
    for (let i = 0; i < hue; i++) {
      fns.push(() => chroma(color).darken())
    }
    for (let i = 0; i < hue; i++) {
      fns.push(() => chroma(color).brighten())
    }
    const fn = sample(fns)
    color = fn()
  }
  return (
    <div style={{ display: 'flex', alignItems: 'center' }}>
      <div style={{ display: 'flex', flexWrap: 'wrap', width: '50%', marginRight: 8 }}>
        {els}
      </div>
      <div>
        <div>
          <label style={{ fontWeight: 'bold' }}>
            <input
              type="range"
              min="0"
              max="10"
              step="1"
              value={hue}
              onChange={e => setHue(e.target.value)}
            />
            Hue {hue}
          </label>
        </div>
        <div>
          <label style={{ fontWeight: 'bold' }}>
            <input
              type="range"
              min="0"
              max="10"
              step="1"
              value={saturate}
              onChange={e => setSaturate(e.target.value)}
            />
            Saturate {saturate}
          </label>
        </div>
        <div>
          <label style={{ fontWeight: 'bold' }}>
            <input
              type="range"
              min="0"
              max="10"
              step="1"
              value={desaturate}
              onChange={e => setDesaturate(e.target.value)}
            />
            Desaturate {desaturate}
          </label>
        </div>
        <div>
          <label style={{ fontWeight: 'bold' }}>
            <input
              type="range"
              min="0"
              max="10"
              step="1"
              value={darken}
              onChange={e => setDarken(e.target.value)}
            />
            Darken {darken}
          </label>
        </div>
        <div>
          <label style={{ fontWeight: 'bold' }}>
            <input
              type="range"
              min="0"
              max="10"
              step="1"
              value={brighten}
              onChange={e => setBrighten(e.target.value)}
            />
            Brighten {brighten}
          </label>
        </div>
      </div>
    </div>
  )
}

<RandomHSLRotateColorsAdjust />

When I initially built this interactive component, it made me realize that
hue manipulation seemed to bring in the grays and whites which was surprising
to me.

### Sporadic sampling of multiple algorithms

COMBINE THEM ALL!!!!

TODO: Elaborate here, and maybe even make interactive by allowing the toggling
of algorithms.

export const RandomEvolvingColors = ({ count = 100 }) => {
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  let color = randomHexColor()
  const els = []
  for (let i = 0; i < count; i++) {
    els.push(<div style={{ height: 16, width: 16, backgroundColor: color }} />)
    //const [h, s, l] = chroma(color).hsl()
    const fns = [
      () => chroma(color).saturate(),
      () => chroma(color).desaturate(),
      () => chroma.blend(color, randomHexColor(), 'overlay'),
      () => chroma(color).brighten(),
      () => chroma(color).darken(),
      () => chroma(color).set('hsl.h', '*.5')
    ]
    const fn = sample(fns)
    color = fn()
  }
  return (
    <div style={{ display: 'flex', flexWrap: 'wrap' }}>
      {els}
    </div>
  )
}

<RandomEvolvingColors />

## Randomizing multiple colors

Colors make up multiple aspects of a button. The border, background color, text color
and even box shadow all have aspects of color. They're all interrelated, too. If
we naively generate all as separate colors without considering their relation a
large amount of generated buttons will not look nice.

When we account for the relation between these different, but related, aspects of
a button, we're still missing another key piece.

### Three random colors

When we introduce three colors, we start to expose a bit of a relationship. Each time
you click the palette, all three colors are regenerated. This allows you to cycle through
a lot of potential palettes that may or may not look nice together.

It can be frustrating, though, if you like two of the colors and only want to change
one of them.

This provides a feeling of "searching", but doesn't allow you to truly hone in on what
you're looking for.

export const RandomColorRegenerator2 = () => {
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  const generateColors = () => ([
    randomHexColor(),
    randomHexColor(),
    randomHexColor()
  ])
  const [colors, setColors] = React.useState(generateColors())
  return (
    <div
      onClick={() => setColors(generateColors())}
      style={{ display: 'flex' }}
    >
      <div
        style={{
          flex: '1',
          height: '20vh',
          cursor: 'pointer',
          backgroundColor: colors[0]
        }}
      />
      <div
        style={{
          flex: '1',
          height: '20vh',
          cursor: 'pointer',
          backgroundColor: colors[1]
        }}
      />
      <div
        style={{
          flex: '1',
          height: '20vh',
          cursor: 'pointer',
          backgroundColor: colors[2]
        }}
      />
    </div>
  )
}

<RandomColorRegenerator2 />

### Three random colors with isolated regeneration

Below, each color is independently generated when the swatch is clicked. This
gives you more granularity since you can build your palette and hone in on
what you're looking for.

Though, it's more difficult to perform an initial search since each color needs
to be worked through one at a time.

export const RandomColorRegenerator3 = () => {
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  const [color1, setColor1] = React.useState(randomHexColor())
  const [color2, setColor2] = React.useState(randomHexColor())
  const [color3, setColor3] = React.useState(randomHexColor())
  return (
    <div style={{ display: 'flex' }}>
      <div
        onClick={() => setColor1(randomHexColor())}
        style={{
          flex: '1',
          height: '20vh',
          cursor: 'pointer',
          backgroundColor: color1
        }}
      />
      <div
        onClick={() => setColor2(randomHexColor())}
        style={{
          flex: '1',
          height: '20vh',
          cursor: 'pointer',
          backgroundColor: color2
        }}
      />
      <div
        onClick={() => setColor3(randomHexColor())}
        style={{
          flex: '1',
          height: '20vh',
          cursor: 'pointer',
          backgroundColor: color3
        }}
      />
    </div>
  )
}

<RandomColorRegenerator3 />

### Three random colors with pinning

If we allow colors to be pinned, then we can quickly search _and_ hone in
on a color palette. It allows the user to be deliberate when generating colors
that are related to each other.

_**Note:** There's a project, [Color Mind](http://colormind.io/), that is doing some pretty
interesting work when it comes to more intelligently generating colors using
[GANs](https://en.wikipedia.org/wiki/Generative_adversarial_network)._

export const RandomColorRegeneratorPin = () => {
  const randomHexColor = () => {
    return '#' + ('000000' + Math.floor(Math.random()*16777215).toString(16)).slice(-6)
  }
  const [color1, setColor1] = React.useState({
    color: randomHexColor(),
    isPinned: false
  })
  const [color2, setColor2] = React.useState({
    color: randomHexColor(),
    isPinned: false
  })
  const [color3, setColor3] = React.useState({
    color: randomHexColor(),
    isPinned: false
  })
  const regenerateColors = () => {
    if (!color1.pinned) {
      setColor1({
        color: randomHexColor(),
        pinned: false
      })
    }
    if (!color2.pinned) {
      setColor2({
        color: randomHexColor(),
        pinned: false
      })
    }
    if (!color3.pinned) {
      setColor3({
        color: randomHexColor(),
        pinned: false
      })
    }
  }
  return (
    <div
      onClick={regenerateColors}
      style={{ display: 'flex' }}
    >
      <div
        style={{
          flex: '1',
          height: '20vh',
          cursor: 'pointer',
          position: 'relative',
          backgroundColor: color1.color
        }}
      >
        <div
          style={{
            backgroundColor: 'white',
            position: 'absolute',
            bottom: 0,
            right: 0,
            paddingTop: 2,
            paddingLeft: 8,
            paddingRight: 8,
            paddingBottom: 2
          }}
        >
          {color1.pinned ? (
            <Lock
              style={{
              }}
              onClick={e => {
                e.stopPropagation()
                setColor1({
                  ...color1,
                  pinned: false
                })
              }}
            />
          ) : (
            <Unlock
              style={{
              }}
              onClick={e => {
                e.stopPropagation()
                setColor1({
                  ...color1,
                  pinned: true
                })
              }}
            />
          )}
        </div>
      </div>
      <div
        style={{
          flex: '1',
          height: '20vh',
          cursor: 'pointer',
          position: 'relative',
          backgroundColor: color2.color
        }}
      >
        <div
          style={{
            backgroundColor: 'white',
            position: 'absolute',
            bottom: 0,
            right: 0,
            paddingTop: 2,
            paddingLeft: 8,
            paddingRight: 8,
            paddingBottom: 2
          }}
        >
          {color2.pinned ? (
            <Lock
              style={{
              }}
              onClick={e => {
                e.stopPropagation()
                setColor2({
                  ...color2,
                  pinned: false
                })
              }}
            />
          ) : (
            <Unlock
              style={{
              }}
              onClick={e => {
                e.stopPropagation()
                setColor2({
                  ...color2,
                  pinned: true
                })
              }}
            />
          )}
        </div>
      </div>
      <div
        style={{
          flex: '1',
          height: '20vh',
          cursor: 'pointer',
          position: 'relative',
          backgroundColor: color3.color
        }}
      >
        <div
          style={{
            backgroundColor: 'white',
            position: 'absolute',
            bottom: 0,
            right: 0,
            paddingTop: 2,
            paddingLeft: 8,
            paddingRight: 8,
            paddingBottom: 2
          }}
        >
          {color3.pinned ? (
            <Lock
              style={{
              }}
              onClick={e => {
                e.stopPropagation()
                setColor3({
                  ...color3,
                  pinned: false
                })
              }}
            />
          ) : (
            <Unlock
              style={{
              }}
              onClick={e => {
                e.stopPropagation()
                setColor3({
                  ...color3,
                  pinned: true
                })
              }}
            />
          )}
        </div>
      </div>
    </div>
  )
}

<RandomColorRegeneratorPin />

## What's up with all the browns?
